---
date: 2025-12-19
tags: [git, stack, pr]
title: Git Stack
---

<Tweet tweetLink="ericclemmons/status/1998471917368430894" />

I've been a big fan of [GitButler](https://gitbutler.com/) for a few years now â€“
it let's me work on multiple changes at once, and then split them up into independent PRs.

![GitButler Screenshot](https://gitbutler.com/images/app-preview-dark.png)

What I've found lately is that there's been more ceremony (read: friction) with splitting
up my changes across lanes.

**What I wanted was a way to work in 1 branch, but break up logical chuncks into PRs that can be reviewed & land independently.**

## Let AI do it

AI is great with nuance, non-deterministic decisions based on context. The workflow I wanted was:

1. `git switch -c $USER`
   This is my equivalent of `main` that I **always** work on.
1. Add Feature A
1. `git add && git commit && git push`
1. Add Feature B
1. `git add && git commit && git push`
1. Add `lodash` to `package.json`
1. Use `lodash` in Feature B
1. `git add && git commit && git push`

In GitHub, I wanted to see:

- PR #1: â˜‚ï¸ eric
  This is an "umbrella" PR that can be used to review all changes in one place.
  At the start of the week, there'll often be no changes.
  At the end of the week, there'll be a lot of changes here but broken up into multiple PRs.

- PR #2: Feature A (`pr-split/eric/feature-a`)
  This PR is automatically created by AI based on changes in the â˜‚ï¸ that AI determines can be landed independently to `main`.
- PR #3: Feature B (`pr-split/eric/feature-b`)
  Similarly, AI creates a separate PR that's logically different from Feature A.

  - PR #4: Replace custom utils with `lodash` (`pr-split/eric/feature-b/refactor-lodash`)
    AI creates a "stack" for this refactor that **depends on Feature B**, but can be reviewed independently.

Claude Code cranked this out with fairly good success:

- [.husky/pre-commit-msg](https://github.com/ericclemmons/ericclemmons/blob/e5a8a3e9549fd3ac1c21d163057773251b7edc45/.husky/prepare-commit-msg)
- [.github/workflows/pr-splitter.yml](https://github.com/ericclemmons/ericclemmons/blob/main/.github/workflows/pr-splitter.yml)

The **secret sauce** is using [Git Trailers](https://git-scm.com/docs/git-interpret-trailers) for metadata that survives rebasing.
When rebasing the `$USER` branch against `main`, the commit hashes change!
But I needed a deterministic way the original commit to avoid duplicative work.
(Alternatively, I think the `git diff` would be a better hash since those are the contents that AI is considering!)

I was able to make it **work**, but there would be a lot of tweaking to make it **work well**:

- Optimized to use increasingly more powerful models based on the complexity of the changes
- Optimize for _incremental_ commits
- Only generate PRs when the â˜‚ï¸ PR is "Ready for Review"

What was nice is that AI could also listen to a PR Review Comment and adjust the PRs accordingly!

> /pr-splitter This change should be on #3, not #4

Or, if I wanted to re-run the script for whatever reason, I could manually trigger the workflow, or just comment:

> ğŸ”€

## git-stack-cli

And this is why I tweet:

<Tweet tweetLink="magusnn/status/1999929058868793668" />

Installation is a simple:

```shell
brew install magus/git-stack/git-stack
```

Then, I had to make sure that my `origin` references were correct.
Otherwise, I had a stale reference to `origin/main` that had HUNDREDS of invalid commits!

```shell
git remote prune origin
```

Finally, I was ready for my first stack:

```shell
$ git stack

â­‘ NEW   0/26   Unassigned


ğŸ‘‹ Welcome to git stack!
Press c to (c)reate a new PR

â—¯ Prettier
â—¯ Move opencode workaround to post-commit hook
â—¯ Add test file 15
â—¯ Refactor prepare-commit-msg hook for streamlined commit generation
â—¯ Add test-file14.txt
â—¯ Test 13
â—¯ Only test-file12.txt is staged
â—¯ Manual message for test-file11.
â—¯ Add test-file8.txt
â—¯ Add test-file7.txt
â—¯ Add test-file6.txt
â—¯ Manual test-file4 commit to see if opencode is doing `git add .`
â—¯ chore: test commit
â—¯ Add test-file2.txt
â—¯ Add test file
â—¯ Update opencode permissions in prepare-commit-msg hook
â—¯ Add rule against tool calls and git operations in prepare-commit-msg
â—¯ Draft git-stack
â—¯ Remove PR Splitter feature
â—¯ Remove Husky pre-commit hook
â—¯ Update opencode permission defaults to boolean false
â—¯ Add prepare-commit-msg section to auto-commit blog post
â—¯ Update opencode permission key from edit to write
â—¯ Add blog post on auto-commit messages with OpenCode
â—¯ Integrate opencode for automatic commit message generation
â—¯ Add Flox blog post

26 unassigned commits
Press c to (c)reate a new PR
Press â† and â†’ to view PRs
Press Enter to toggle commit selection
```

After <kbd>c</kbd>, `Add Flox blog post` was automatically prefilled as a PR title.

<kbd>s</kbd> then synced this to GitHub as [Add Flox blog post](https://github.com/ericclemmons/ericclemmons/pull/99):

```shell
â­‘ NEW   0/26   Unassigned

Created new PR [Add Flox blog post] (eric---4h5sg2pldxtz8-)

â­‘ NEW      0/25   Unassigned
âœ” SYNCED   1/1    Add Flox blog post   https://github.com/ericclemmons/ericclemmons/pull/99
```

Now that I've figured out the flow for one of them, I learned that the workflow is basically:

1. <kbd>c</kbd> to create a new PR (if you don't have one already)
1. <kbd>â†‘</kbd> and <kbd>â†“</kbd> to highlight a commit and <kbd>Enter</kbd> to *Assign**
   it to the current PR
1. <kbd>â†</kbd> and <kbd>â†’</kbd> to navigate between available PRs{' '}
1. Finally, <kbd>s</kbd> to sync the PRs to GitHub:

```shell
$ git stack
ğŸ“¦ Changes saved to stash

â­‘ NEW      0/25   Unassigned
âœ” SYNCED   1/1    Add Flox blog post   https://github.com/ericclemmons/ericclemmons/pull/99

Created new PR [Test Commits] (eric---4h5shgjoil6oxc)
Created new PR [Automatic git commit messages] (eric---4h5shr5o793bv8)
Created new PR [Draft git-stack] (eric---4h5si6up1575bl)
Created new PR [Remove PR Splitter feature] (eric---4h5si9vt4e_lz_)

â­‘ NEW      0/1     Unassigned
âœ” SYNCED   12/12   Test Commits                    https://github.com/ericclemmons/ericclemmons/pull/100
âœ” SYNCED   1/1     Draft git-stack                 https://github.com/ericclemmons/ericclemmons/pull/101
âœ” SYNCED   2/2     Remove PR Splitter feature      https://github.com/ericclemmons/ericclemmons/pull/103
âœ” SYNCED   9/9     Automatic git commit messages   https://github.com/ericclemmons/ericclemmons/pull/102
âœ” SYNCED   1/1     Add Flox blog post              https://github.com/ericclemmons/ericclemmons/pull/99
âœ… Everything up to date.
âœ… Changes restored from stash
```

Now, I realize my mistake â€“ **this is purely for a _stack_ of PRs, not for independent PRs** like I wanted with my AI experiment.

## Conclusion

I want the best of ~~both~~ three worlds:

1. Single-branch experience like [GitButler](https://gitbutler.com/) (they use `git worktrees` to achieve this internally) so I don't have to `git switch` or `git stash` constantly.
1. Easy way to split changes between dependent PRs like [git-stack-cli](https://github.com/magusnn/git-stack-cli), but still have independent PRs that aren't stacked like [GitButler](https://gitbutler.com/).
1. Do less "book keeping" with AI, and only have human intervention when AI gets it wrong.
